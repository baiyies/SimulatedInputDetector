# SimulatedInputDetector

![Language](https://img.shields.io/badge/language-C%2B%2B-blue.svg)
![Platform](https://img.shields.io/badge/platform-Windows-0078D6.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

A C++ Win32 demonstration project that shows how to reliably detect and block simulated (injected) mouse clicks, differentiating them from physical user input.

This project is the result of a deep dive into Windows input handling and addresses several common pitfalls, making it a valuable resource for anyone working with system-level hooks or developing anti-cheat/anti-botting mechanisms.

<img src="https://github.com/baiyies/SimulatedInputDetector/blob/main/images/1.png?raw=true"/>

## How It Works

The core of the detection mechanism relies on a `WH_MOUSE_LL` (low-level mouse) hook.

1.  **Hook Installation**: `SetWindowsHookEx(WH_MOUSE_LL, ...)` installs a global hook that intercepts all low-level mouse events. The callback function (`LowLevelMouseProc`) always executes within our application's thread, avoiding DLL injection.
2.  **The Injection Flag**: The `MSLLHOOKSTRUCT` passed to the callback contains a `flags` member. If this contains the `LLMHF_INJECTED` flag, we know the event was generated by software using an API like `SendInput`.
3.  **Coordinate-Based Hit-Testing**: To check if the click occurred on our window, we do the following:
    a. Get the mouse's absolute screen coordinates from the `MSLLHOOKSTRUCT`.
    b. Get our window's client area rectangle using `GetClientRect`.
    c. Convert this client rectangle to absolute screen coordinates using `ClientToScreen`.
    d. Use `PtInRect` to determine if the mouse coordinates are within our window's client area on the screen.
4.  **Blocking the Event**: If an injected click is detected, the callback function simply **returns a non-zero value (1)** and **does not call `CallNextHookEx`**. This tells the system to discard the message, effectively "consuming" it before it can reach the target window.
